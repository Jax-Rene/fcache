<!--
 * @Description: In User Settings Edit
 * @Author: your name
 * @Date: 2019-09-29 21:04:17
 * @LastEditTime: 2019-10-01 10:52:34
 * @LastEditors: Please set LastEditors
 -->
# fcache

fcache 是一个基于文件的缓存系统。开发这个组件的初衷主要是为了解决生产环境中大量的定时查询直接打到MySQL服务上，造成MySQL服务跑高，最终影响到其他服务。这些查询通常具有如下特征：
1. 全表指定某些列的查询，量级较大（一次查询通常10W条以上的数据）
2. 多客户端查询（三数据中心，大量计算作业查询）
3. 弱一致性，定时查询，获取数据快照

实际上，在MySQL架构中本身已提供 “查询缓存” 服务，但是由于其极大受到数据更新、一致性问题影响，效果十分的差，以至于MySQL在8.0版本后已经砍掉该功能。

在这之前，我们尝试过使用Redis来缓存这部分数据，Redis作为缓存具有高效、易用的特性。但是单点Redis的QPS在10W左右，同时Redis的横向扩容机制是基于对海量Key的Hash。所以使用Redis作为缓存的话，我们只有两种选择：
1. 将表数据拆分，按数据存储到大量的Key中（这里可以用反向索引实现条件查询）
2. 直接将整表序列化存储于一个大Key

基于方案1，我们曾经借鉴了ES的反向索引方式，设计一套Redis支持条件查询的方式，但是我们的查询方大多为计算作业，一次通常需要查询全表数据，这可能造成了上10W的QPS，且存在大量的作业，多个数据中心。因此最终该方案由于性能问题无法落地。

基于方案2，虽然实现起来简单，但是方案本身限制了Redis横向扩容的性能。这导致在生产中，时常触发读取、写入失败。并且大数据的序列化、反序列、写入读取效率也极大的影响到我们正确数据的同步。

显然，基于Redis的方案并不能满足我们获取大量数据在客户端做本地缓存的需求，因此我尝试写了这个基于文件的缓存组件。

## 核心特性
fcache 的出发点是为了解决大量客户端本地缓存的需求。因此核心特性主要包括如下几点：

1. 高性能
2. 插件化
3. 横向扩容
4. 高可用
5. 开箱即用

下面，我们围绕着每个特性，来看下 fcache 是如何保证上面的特性。

### 1. 高性能
在性能方面，是缓存组件的一个核心考核点。若缓存组件因为性能问题，导致客户端的请求卡顿、失败那么缓存组件的可用性就非常低了。
为了解决性能问题，我们从三个方面来优化：
1. 客户端读取缓存部分：客户端使用定制化Client API，在客户端层借鉴浏览器HTTP缓存机制。
* 设置了max-age的新鲜度，若更新时间低于max-age则不发起更新请求
* 若过期后，则发起更新请求，同时带上本地缓存数据的Etag信息（如果是列式存储，则带上对于列的Etag信息）
* 服务端收到请求后，判断若整份数据在此期间未发生变化，则返回 304 Not Modified，客户端不更新任何数据
* 服务端收到请求后，若发现至少一个列的Etag值发生变化，则返回对应列的数据以及对应的Etag信息
2. 基于文件的 Zero Memory Copy 机制
本质上，fcache就是一个文件下载系统。文件下载系统一般实现有两种方式：
* 基于内存的方式：客户端请求缓存，服务端将数据从内存写向网卡。
* 基于文件的方式：客户端请求缓存，服务端将数据从磁盘读入内存，然后再写入网卡。
本质上，基于文件的方式会被基于内存的方式更繁琐，效率也更低。但是在没有请求的时候，数据落地在文件中，不占用堆内存。这避免了很多内存的问题，例如大量缓存可能会造成大量FULL GC最终影响服务的性能，极端情况下，甚至引起OOM等问题。把数据落地在磁盘上，也使得缓存系统的存储能力有了数十倍的提升。

那么，有兼顾的办法吗? 我们可以使用 Netty Zero Memory Copy机制来解决。

> 什么是 Zero Memory Copy?
>





